using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace SplineMesh {
    /// <summary>
    /// Deform a mesh and place it along a spline, given various parameters.
    /// 
    /// This class intend to cover the most common situations of mesh bending. It can be used as-is in your project,
    /// or can serve as a source of inspiration to write your own procedural generator.
    /// </summary>
    [ExecuteInEditMode]
    [SelectionBase]
    [DisallowMultipleComponent]
    public class SplineMeshTiling : MonoBehaviour {
        private GameObject[] generated;
        private Spline spline = null;
        private bool toUpdate = false;

        [System.Serializable]
        private struct Meshes
        {
            public Mesh mesh;
            public Material material;
        }

        [System.Serializable]
        private struct MeshData
        {
            public Meshes[] meshes;
            public bool enableCollision;
            public bool enableMeshRenderer;
        }
        [SerializeField] private MeshData[] meshData;

        [SerializeField] private int numOfGeneratedMeshes = 1;

        //[Tooltip("Material to apply on the bent dmesh.")]
        //public Material material;
        [Tooltip("Physic material to apply on the bent mesh.")]
        public PhysicMaterial physicMaterial;
        [Tooltip("Translation to apply on the mesh before bending it.")]
        public Vector3 translation;
        [Tooltip("Rotation to apply on the mesh before bending it.")]
        public Vector3 rotation;
        [Tooltip("Scale to apply on the mesh before bending it.")]
        public Vector3 scale = Vector3.one;

        //[Tooltip("If true, a mesh collider will be generated.")]
        //public bool generateCollider = true;

        [Tooltip("If true, the mesh will be bent on play mode. If false, the bent mesh will be kept from the editor mode, allowing lighting baking.")]
        public bool updateInPlayMode;

        [Tooltip("If true, a mesh will be placed on each curve of the spline. If false, a single mesh will be placed for the whole spline.")]
        public bool curveSpace = false;

        [Tooltip("The mode to use to fill the choosen interval with the bent mesh.")]
        public MeshBender.FillingMode mode = MeshBender.FillingMode.StretchToInterval;

        [Tooltip("Allow mesh regeneration")]
        [SerializeField] private bool allowMeshRegeneration = true;

        [SerializeField] private bool lockMeshData = true;

        [Header("The backup mesh and material, when no other exists")]
        [SerializeField] private Mesh backupMesh = null;
        [SerializeField] private Material backupMaterial = null;

        private void OnEnable() {
            if (!allowMeshRegeneration)
            {
                return;
            }

            if (lockMeshData == false)
            {
                meshData = new MeshData[numOfGeneratedMeshes];

                for (int i = 0; i < meshData.Length; ++i)
                {
                    meshData[i].meshes = new Meshes[spline.curves.Count];
                }
            }

            generated = new GameObject[numOfGeneratedMeshes];

            for (int j = 0; j < numOfGeneratedMeshes; ++j)
            {
                // tip : if you name all generated content in the same way, you can easily find all of it
                // at once in the scene view, with a single search.
                string generatedName = "generated by " + GetType().Name + j;
                var generatedTranform = transform.Find(generatedName);
                generated[j] = generatedTranform != null ? generatedTranform.gameObject : UOUtility.Create(generatedName, gameObject);

                spline = GetComponentInParent<Spline>();
                spline.NodeListChanged += (s, e) => toUpdate = true;

                toUpdate = true;
            }
        }

        private void OnValidate() {
            if (!allowMeshRegeneration)
            {
                return;
            }

            if (spline == null) return;
            toUpdate = true;
        }

        private void Update() {
            // we can prevent the generated content to be updated during playmode to preserve baked data saved in the scene
            if (!updateInPlayMode && Application.isPlaying) return;

            if (toUpdate) {
                toUpdate = false;
                CreateMeshes();
            }
        }

        public void CreateMeshes() {
            for (int j = 0; j < numOfGeneratedMeshes; ++j)
            {
                Debug.Log("Regenerating mesh " + generated[j]);

                var used = new List<GameObject>();

                if (curveSpace)
                {
                    int i = 0;
                    foreach (var curve in spline.curves)
                    {
                        Mesh mesh = null;
                        Material mat = null;
                        if (meshData[j].meshes[i].mesh == null)
                        {
                            mesh = backupMesh;
                            Debug.LogWarning("Can't find mesh - using backup");
                        }
                        else
                        {
                            mesh = meshData[j].meshes[i].mesh;
                        }

                        if (meshData[j].meshes[i].material == null)
                        {
                            mat = backupMaterial;
                            Debug.LogWarning("Can't find material - using backup");
                        }
                        else
                        {
                            mat = meshData[j].meshes[i].material;
                        }

                        var go = FindOrCreate("segment " + i++ + " mesh", mesh, mat, j);
                        go.GetComponent<MeshBender>().SetInterval(curve);
                        go.GetComponent<MeshCollider>().enabled = meshData[j].enableCollision;
                        go.GetComponent<MeshRenderer>().enabled = meshData[j].enableMeshRenderer;
                        used.Add(go);
                    }
                }
                else
                {
                    var go = FindOrCreate("segment 1 mesh", backupMesh, backupMaterial, j);
                    go.GetComponent<MeshBender>().SetInterval(spline, 0);
                    go.GetComponent<MeshCollider>().enabled = meshData[j].enableCollision;
                    go.GetComponent<MeshRenderer>().enabled = meshData[j].enableMeshRenderer;
                    used.Add(go);
                }

                // we destroy the unused objects. This is classic pooling to recycle game objects.
                foreach (var go in generated[j].transform
                    .Cast<Transform>()
                    .Select(child => child.gameObject).Except(used))
                {
                    UOUtility.Destroy(go);
                }
            }
        }

        private GameObject FindOrCreate(string name, Mesh mesh, Material material, int generatedMeshIndex) {
            Debug.Log(name);
                
            var childTransform = generated[generatedMeshIndex].transform.Find(name);
            GameObject res;
            if (childTransform == null)
            {
                res = UOUtility.Create(name,
                    generated[generatedMeshIndex],
                    typeof(MeshFilter),
                    typeof(MeshRenderer),
                    typeof(MeshBender),
                    typeof(MeshCollider));
                res.isStatic = true;
            }
            else
            {
                res = childTransform.gameObject;
            }
            res.GetComponent<MeshRenderer>().material = material;
            res.GetComponent<MeshCollider>().material = physicMaterial;
            MeshBender mb = res.GetComponent<MeshBender>();
            mb.Source = SourceMesh.Build(mesh)
                .Translate(translation)
                .Rotate(Quaternion.Euler(rotation))
                .Scale(scale);
            mb.Mode = mode;
            return res;
        }
    }
}
